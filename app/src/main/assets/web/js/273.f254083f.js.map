{"version":3,"file":"js/273.f254083f.js","mappings":"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","sources":["webpack://novel-web/../src/utils/compatibility.js","webpack://novel-web/../src/components/ResizeObserver.vue","webpack://novel-web/../src/components/ResizeObserver.vue?59d1","webpack://novel-web/./node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","webpack://novel-web/../src/index.ts","webpack://novel-web/../src/config.js","webpack://novel-web/../src/scrollparent.js","webpack://novel-web/../src/components/common.js","webpack://novel-web/../src/utils.js","webpack://novel-web/../src/components/RecycleScroller.vue","webpack://novel-web/../src/components/RecycleScroller.vue?f97b","webpack://novel-web/../src/components/DynamicScroller.vue","webpack://novel-web/../src/components/DynamicScroller.vue?db6b","webpack://novel-web/../src/components/DynamicScrollerItem.vue","webpack://novel-web/./src/components/VirtualList.vue","webpack://novel-web/./src/components/VirtualList.vue?9667"],"sourcesContent":["export function getInternetExplorerVersion () {\n  const ua = window.navigator.userAgent\n\n  const msie = ua.indexOf('MSIE ')\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10)\n  }\n\n  const trident = ua.indexOf('Trident/')\n  if (trident > 0) {\n    // IE 11 => return version number\n    const rv = ua.indexOf('rv:')\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10)\n  }\n\n  const edge = ua.indexOf('Edge/')\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10)\n  }\n\n  // other browser\n  return -1\n}\n","<template>\n  <div\n    class=\"resize-observer\"\n    tabindex=\"-1\"\n  />\n</template>\n\n<script>\nimport { nextTick } from 'vue'\nimport { getInternetExplorerVersion } from '../utils/compatibility'\n\nlet isIE\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true\n    isIE = getInternetExplorerVersion() !== -1\n  }\n}\n\nexport default {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat()\n    nextTick(() => {\n      this._w = this.$el.offsetWidth\n      this._h = this.$el.offsetHeight\n      if (this.emitOnMount) {\n        this.emitSize()\n      }\n    })\n    const object = document.createElement('object')\n    this._resizeObject = object\n    object.setAttribute('aria-hidden', 'true')\n    object.setAttribute('tabindex', -1)\n    object.onload = this.addResizeHandlers\n    object.type = 'text/html'\n    if (isIE) {\n      this.$el.appendChild(object)\n    }\n    object.data = 'about:blank'\n    if (!isIE) {\n      this.$el.appendChild(object)\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers()\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth\n        this._h = this.$el.offsetHeight\n        this.emitSize()\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      })\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify)\n      this.compareAndNotify()\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify)\n        }\n        this.$el.removeChild(this._resizeObject)\n        this._resizeObject.onload = null\n        this._resizeObject = null\n      }\n    },\n  },\n}\n</script>\n\n<style scoped>\n.resize-observer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -1;\n  width: 100%;\n  height: 100%;\n  border: none;\n  background-color: transparent;\n  pointer-events: none;\n  display: block;\n  overflow: hidden;\n  opacity: 0;\n}\n\n.resize-observer:deep(object) {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n</style>\n","<template>\n  <div\n    class=\"resize-observer\"\n    tabindex=\"-1\"\n  />\n</template>\n\n<script>\nimport { nextTick } from 'vue'\nimport { getInternetExplorerVersion } from '../utils/compatibility'\n\nlet isIE\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true\n    isIE = getInternetExplorerVersion() !== -1\n  }\n}\n\nexport default {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat()\n    nextTick(() => {\n      this._w = this.$el.offsetWidth\n      this._h = this.$el.offsetHeight\n      if (this.emitOnMount) {\n        this.emitSize()\n      }\n    })\n    const object = document.createElement('object')\n    this._resizeObject = object\n    object.setAttribute('aria-hidden', 'true')\n    object.setAttribute('tabindex', -1)\n    object.onload = this.addResizeHandlers\n    object.type = 'text/html'\n    if (isIE) {\n      this.$el.appendChild(object)\n    }\n    object.data = 'about:blank'\n    if (!isIE) {\n      this.$el.appendChild(object)\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers()\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth\n        this._h = this.$el.offsetHeight\n        this.emitSize()\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      })\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify)\n      this.compareAndNotify()\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify)\n        }\n        this.$el.removeChild(this._resizeObject)\n        this._resizeObject.onload = null\n        this._resizeObject = null\n      }\n    },\n  },\n}\n</script>\n\n<style scoped>\n.resize-observer {\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -1;\n  width: 100%;\n  height: 100%;\n  border: none;\n  background-color: transparent;\n  pointer-events: none;\n  display: block;\n  overflow: hidden;\n  opacity: 0;\n}\n\n.resize-observer:deep(object) {\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n  pointer-events: none;\n  z-index: -1;\n}\n</style>\n","import { nextTick } from 'vue';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState = /*#__PURE__*/function () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && typeof this.options.intersection.threshold === 'number' ? this.options.intersection.threshold : 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction beforeMount(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction updated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    beforeMount(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: beforeMount,\n  updated: updated,\n  unmounted: unmounted\n};\n\nfunction install(app) {\n  app.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","export type EventType = string | symbol;\n\n// An event handler can take an optional event argument\n// and should not return a value\nexport type Handler<T = any> = (event?: T) => void;\nexport type WildcardHandler = (type: EventType, event?: any) => void;\n\n// An array of all currently registered event handlers for a type\nexport type EventHandlerList = Array<Handler>;\nexport type WildCardEventHandlerList = Array<WildcardHandler>;\n\n// A map of event types and their corresponding event handlers.\nexport type EventHandlerMap = Map<EventType, EventHandlerList | WildCardEventHandlerList>;\n\nexport interface Emitter {\n\tall: EventHandlerMap;\n\n\ton<T = any>(type: EventType, handler: Handler<T>): void;\n\ton(type: '*', handler: WildcardHandler): void;\n\n\toff<T = any>(type: EventType, handler: Handler<T>): void;\n\toff(type: '*', handler: WildcardHandler): void;\n\n\temit<T = any>(type: EventType, event?: T): void;\n\temit(type: '*', event?: any): void;\n}\n\n/**\n * Mitt: Tiny (~200b) functional event emitter / pubsub.\n * @name mitt\n * @returns {Mitt}\n */\nexport default function mitt(all?: EventHandlerMap): Emitter {\n\tall = all || new Map();\n\n\treturn {\n\n\t\t/**\n\t\t * A Map of event names to registered handler functions.\n\t\t */\n\t\tall,\n\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to listen for, or `\"*\"` for all events\n\t\t * @param {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tconst added = handlers && handlers.push(handler);\n\t\t\tif (!added) {\n\t\t\t\tall.set(type, [handler]);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t * @param {string|symbol} type Type of event to unregister `handler` from, or `\"*\"`\n\t\t * @param {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff<T = any>(type: EventType, handler: Handler<T>) {\n\t\t\tconst handlers = all.get(type);\n\t\t\tif (handlers) {\n\t\t\t\thandlers.splice(handlers.indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * Note: Manually firing \"*\" handlers is not supported.\n\t\t *\n\t\t * @param {string|symbol} type The event type to invoke\n\t\t * @param {Any} [evt] Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit<T = any>(type: EventType, evt: T) {\n\t\t\t((all.get(type) || []) as EventHandlerList).slice().map((handler) => { handler(evt); });\n\t\t\t((all.get('*') || []) as WildCardEventHandlerList).slice().map((handler) => { handler(type, evt); });\n\t\t}\n\t};\n}\n","export default {\n  itemsLimit: 1000,\n}\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import { defineComponent as _defineComponent } from 'vue';\nimport { renderSlot as _renderSlot, unref as _unref, withCtx as _withCtx, createVNode as _createVNode, resolveComponent as _resolveComponent, createElementVNode as _createElementVNode, createSlots as _createSlots, openBlock as _openBlock, createBlock as _createBlock } from \"vue\";\nconst _hoisted_1 = {\n  class: \"virtual-list__loading\"\n};\nimport \"vue-virtual-scroller/dist/vue-virtual-scroller.css\";\nimport { DynamicScroller, DynamicScrollerItem } from \"vue-virtual-scroller\";\n\nimport { computed, ref } from 'vue';\nexport default /*@__PURE__*/_defineComponent({\n  ...{\n    name: \"virtual-list\"\n  },\n  __name: 'VirtualList',\n  props: {\n    // 列表数据\n    list: {\n      type: Array,\n      required: true\n    },\n    // item最小尺寸\n    minItemSize: {\n      type: Number,\n      required: true\n    },\n    // 滚动缓冲区\n    buffer: {\n      type: Number,\n      default: 500\n    },\n    // 加载中\n    loading: {\n      type: Boolean,\n      default: false\n    },\n    // item唯一key\n    keyField: {\n      type: String,\n      required: true\n    }\n  },\n  emits: [\"scroll-to-bottom\", \"current-visible\"],\n  setup(__props, {\n    emit: __emit\n  }) {\n    const emit = __emit;\n    const props = __props;\n    const listLength = computed(() => props.list.length); // 列表长度\n    const af = ref(); // 动画帧Id\n    /**\r\n     * @description: 处理视图更新\r\n     * @param {number} _startIndex 起始渲染位置\r\n     * @param {number} endIndex 结束渲染位置\r\n     * @param {number} _visibleStartIndex 起始可视位置\r\n     * @param {number} visibleEndIndex 结束可视位置\r\n     */\n    const handleUpdate = (_startIndex, endIndex, _visibleStartIndex, visibleEndIndex) => {\n      if (af.value !== undefined) cancelAnimationFrame(af.value);\n      af.value = requestAnimationFrame(() => {\n        if (endIndex === listLength.value) {\n          emit(\"scroll-to-bottom\");\n        }\n        emit(\"current-visible\", props.list[visibleEndIndex], visibleEndIndex);\n      });\n    };\n    return (_ctx, _cache) => {\n      const _component_van_loading = _resolveComponent(\"van-loading\");\n      return _openBlock(), _createBlock(_unref(DynamicScroller), {\n        class: \"virtual-list\",\n        items: __props.list,\n        \"min-item-size\": __props.minItemSize,\n        buffer: __props.buffer,\n        keyField: __props.keyField,\n        \"emit-update\": \"\",\n        onUpdate: handleUpdate\n      }, _createSlots({\n        default: _withCtx(({\n          item,\n          index,\n          active\n        }) => [_createVNode(_unref(DynamicScrollerItem), {\n          item: item,\n          active: active,\n          \"data-index\": index\n        }, {\n          default: _withCtx(() => [_renderSlot(_ctx.$slots, \"default\", {\n            item: item,\n            active: active,\n            index: index\n          })]),\n          _: 2\n        }, 1032, [\"item\", \"active\", \"data-index\"])]),\n        _: 2\n      }, [__props.loading ? {\n        name: \"after\",\n        fn: _withCtx(() => [_createElementVNode(\"div\", _hoisted_1, [_createVNode(_component_van_loading)])]),\n        key: \"0\"\n      } : _unref(listLength) === 0 ? {\n        name: \"empty\",\n        fn: _withCtx(() => [_cache[0] || (_cache[0] = _createElementVNode(\"div\", {\n          class: \"virtual-list__empty\"\n        }, \"暂无数据\", -1))]),\n        key: \"1\"\n      } : undefined]), 1032, [\"items\", \"min-item-size\", \"buffer\", \"keyField\"]);\n    };\n  }\n});","/* unplugin-vue-components disabled */import script from \"./VirtualList.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./VirtualList.vue?vue&type=script&setup=true&lang=ts\"\n\nimport \"./VirtualList.vue?vue&type=style&index=0&id=f060d2de&lang=scss&scoped=true\"\n\nimport exportComponent from \"../../node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['__scopeId',\"data-v-f060d2de\"]])\n\nexport default __exports__"],"names":["getInternetExplorerVersion","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","trident","rv","edge","isIE","initCompat","init","script","name","props","emitOnMount","type","Boolean","default","ignoreWidth","ignoreHeight","emits","mounted","nextTick","this","_w","$el","offsetWidth","_h","offsetHeight","emitSize","object","document","createElement","_resizeObject","setAttribute","onload","addResizeHandlers","appendChild","data","beforeUnmount","removeResizeHandlers","methods","compareAndNotify","$emit","width","height","contentDocument","defaultView","addEventListener","removeEventListener","removeChild","class","tabindex","createBlock","_hoisted_1","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","call","slice","test","len","arr2","processOptions","value","options","callback","throttle","delay","timeout","lastState","currentArgs","arguments","undefined","throttled","state","_len","args","_key","leading","apply","concat","clearTimeout","setTimeout","_clear","deepEqual","val1","val2","VisibilityState","el","vnode","observer","frozen","createObserver","_this","destroyObserver","result","entry","once","_ref","throttleOptions","_leading","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","observe","disconnect","get","beforeMount","_ref2","console","warn","_vue_visibilityState","updated","_ref3","oldValue","unmounted","ObserveVisibility","all","Map","on","t","push","set","off","splice","emit","map","config","itemsLimit","regex","parents","node","ps","parentNode","style","prop","getComputedStyle","getPropertyValue","overflow","scroll","getScrollParent","HTMLElement","SVGElement","scrollingElement","documentElement","items","required","keyField","String","direction","validator","includes","listTag","itemTag","simpleArray","supportsPassive","opts","uid","script$2","components","ResizeObserver","ResizeObserver$1","directives","itemSize","Number","gridItems","itemSecondarySize","minItemSize","sizeField","typeField","buffer","pageMode","prerender","emitUpdate","updateInterval","skipHover","listClass","itemClass","pool","totalSize","ready","hoverKey","computed","sizes","accumulator","field","current","computedMinSize","l","size","$_computedMinItemSize","itemIndexByKey","watch","updateVisibleItems","applyPageMode","handler","deep","created","$_startIndex","$_endIndex","$_views","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","error","$nextTick","activated","lastPosition","scrollToPosition","removeListeners","addView","index","item","nr","markRaw","id","used","view","shallowReactive","position","unuseView","fake","unusedViews","unusedPool","handleResize","handleScroll","event","$_updateTimeout","requestUpdate","requestAnimationFrame","continuous","$_refreshTimout","handleVisibilityChange","isVisible","boundingClientRect","checkItem","checkPositionDiff","count","views","startIndex","endIndex","visibleStartIndex","visibleEndIndex","Math","min","getScroll","positionDiff","start","end","beforeSize","$refs","before","scrollHeight","after","afterSize","h","oldI","a","b","remainer","ceil","max","floor","itemsLimitError","unusedIndex","v","Error","newlyUsedView","pop","delete","offset","$_sortTimer","sortViews","getListenerTarget","body","isVertical","scrollState","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","passive","scrollToItem","viewport","scrollDirection","scrollDistance","viewportEl","tagName","scroller","scrollerPosition","log","sort","viewA","viewB","ref","createElementBlock","normalizeClass","$data","$props","_ctx","$options","$slots","openBlock","renderSlot","resolveDynamicComponent","normalizeStyle","Fragment","renderList","mergeProps","hover","toHandlers","mouseenter","active","_hoisted_2","createVNode","_component_ResizeObserver","onNotify","script$1","RecycleScroller","provide","$_resizeObserver","$_vs_onResize","borderBoxSize","resizeObserverSize","inlineSize","blockSize","contentRect","$_vs_id","vscrollData","vscrollParent","vscrollResizeObserver","inheritAttrs","itemsWithSize","$_undefinedMap","forceUpdate","immediate","next","prev","prevActiveTop","activeTop","beforeCreate","$_updates","$_undefinedSizes","$_events","mitt","deactivated","clear","onScrollerResize","onScrollerVisible","force","getItemSize","scrollToBottom","$_scrollingToBottom","cb","_component_RecycleScroller","$attrs","onResize","onVisible","withCtx","itemWithSize","normalizeProps","guardReactiveProps","empty","inject","watchData","sizeDependencies","emitResize","tag","finalActive","onDataUpdate","$_sizeObserved","oldSize","applySize","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","onVscrollUpdate","$_pendingSizeUpdate","computeSize","$_watchData","applyWidthHeight","unobserve","render","__name","list","loading","setup","__props","__emit","listLength","af","handleUpdate","_startIndex","_visibleStartIndex","cancelAnimationFrame","_cache","_component_van_loading","onUpdate","_","fn","__exports__"],"sourceRoot":""}